cargo new project_name  #initializes a new cargo project
cargo build             #builds the project, executable in target/debug/project_name.exe
cargo run               #builds and executes the project
cargo check             #test compile, but doesnt make an executable
cargo build --release   #builds and compiles with optimizations, executable in target/release

***
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2); //prints "x = 5 and y + 2 = 12"
***

cargo doc --open        #builds documentation and opens it in your browser

if we create a variable "let x = 5", we can not change it with "x=3", but we can "shadow" it as such: "let x = 5; let x = x + 1", and we can even change the type (i.e String -> int)

LOOK AT main.rs IN VARIABLES
LOOK AT main.rs IN OWNERSHIP

At any given time, you can have either one mutable reference or any number of immutable references.
References must always be valid.

let slice = &s[0..2]; == let slice = &s[..2];
let slice = &s[3..len]; == let slice = &s[3..];
let slice = &s[0..len]; == let slice = &s[..];

"x.push_str(y)" pushes y string onto x string
"x.push(y)" pushes a character y onto x string

let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used

panic!("") essentially a system interrupt with a custom message
std::io::ErrorKind //the types of errors
.unwrap() //basically just an error catcher.
"Result<T,E>" is the enum default error checker type (lit. Ok(T) and Err(E) )

The "?" operator unwraps a Result<T,E> (or Option) on success, or early-returns the Err (or None) from the enclosing function if it fails.
File::open("hello.txt")?.read_to_string(&mut username)?;
The "?" operator can only be used in functions whose return type is compatible with the value the ? is used on.

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}

how to interpret:
Result<               //I’m returning a Result...
    (),               //…on success I return nothing useful (unit)
    Box<dyn Error>    //…on failure I return some error, and I don’t care about its exact type
>

Use panic! (or unwrap() / expect() in dev) when a bug truly means “this situation is impossible or indicates programmer error”
(i.e the program is in an invalid state and the safest thing is to crash immediately.)
but, perfectly fine (and even preferred) in production for unrecoverable bugs
se Result (whether it’s Result<(), Box<dyn Error>>, anyhow::Result<()>, or your own custom error type) when the failure is expected 
and recoverable in principle (file not found, network timeout, invalid input, etc.).

“panic = bug in my code”
“Result = something external went wrong that isn’t my fault”

put "#[cfg(test)]" above the module you want to test, and "#[test]" above the function(s) within the module you want to test.
execute tests with "cargo test" in CLI